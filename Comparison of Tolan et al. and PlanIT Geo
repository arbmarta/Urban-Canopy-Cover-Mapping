# --------------------------- REFERENCES -------------------------------------------------------------------------------
# Manson, S., Schroeder, J., Van Riper, D., Knowles, K., Kugler, T., Roberts, F., & Ruggles, S. (2024). IPUMS National
# Historical Geographic Information System (Version 19.0) [dataset]. Minneapolis, MN: IPUMS. DOI: 10.18128/D050.V19.0

# --------------------------- PACKAGES ---------------------------------------------------------------------------------
#region

import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import ee

#endregion

# --------------------------- IMPORT SHAPEFILES ------------------------------------------------------------------------
#region

# Define path to the shapefiles
census_block_path = "Canopy Cover Datasets/Census_Block_Groups_Land_Cover_and_Tree_Canopy_Analysis_8507568496359607047/Census_Block_Groups_Land_Cover_and_Tree_Canopy_Analysis.shp"
census_tract_path = "Canopy Cover Datasets/Census_Tract_Land_Cover_and_Tree_Canopy_Analysis_-7678729890310320705/Census_Tract_Land_Cover_and_Tree_Canopy_Analysis.shp"
census_urban_areas_path = "Canopy Cover Datasets/Census_Urban_Areas_Land_Cover_and_Tree_Canopy_Analysis_8856831727344188313/Census_Urban_Areas_Land_Cover_and_Tree_Canopy_Analysis.shp"

# Load the shapefiles using Geopandas
census_block_shapefile = gpd.read_file(census_block_path)
census_tract_shapefile = gpd.read_file(census_tract_path)
census_urban_areas_shapefile = gpd.read_file(census_urban_areas_path)


# Display the first few roads of the shapefiles
print(census_block_shapefile.head())
print(census_tract_shapefile.head())
print(census_urban_areas_shapefile.head())

# Count the number of rows in each shapefile
print(f"Number of rows: {census_block_shapefile.shape[0]}")
print(f"Number of rows: {census_tract_shapefile.shape[0]}")
print(f"Number of rows: {census_urban_areas_shapefile.shape[0]}")

# Display the columns of the census datasets
print(census_block_shapefile.columns)
print(census_tract_shapefile.columns)
print(census_urban_areas_shapefile.columns)

# Print the coordinate reference systems (CRS)
print(f"CRS: {census_block_shapefile.crs}")
print(f"CRS: {census_tract_shapefile.crs}")
print(f"CRS: {census_urban_areas_shapefile.crs}")

#endregion

# --------------------------- DISPLAY SHAPEFILES -----------------------------------------------------------------------
#region

# Plot the Census Block shapefile
census_block_shapefile.plot(edgecolor="green", figsize=(10, 10))
plt.title("Census Block Groups")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

# Plot the Census Tract shapefile
census_tract_shapefile.plot(edgecolor="green", figsize=(10, 10))
plt.title("Census Tracts")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

# Plot the Urban Areas shapefile
census_urban_areas_shapefile.plot(edgecolor="green", figsize=(10, 10))
plt.title("Census Urban Areas")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

#endregion

# --------------------------- DOWNLOAD 1M DATA -------------------------------------------------------------------------
#region

# Trigger the authentication flow
ee.Authenticate()

# Initialize the library
ee.Initialize()

# Define the canopy height image (from the Meta Forest Monitoring asset)
canopy_height = ee.ImageCollection('projects/meta-forest-monitoring-okw37/assets/CanopyHeight').mosaic()

# Apply a mask to retain canopy heights >= 1 meter
masked_canopy_height = canopy_height.updateMask(canopy_height.gte(1))

# Clip the masked image to the census areas
census_block_canopy = masked_canopy_height.clip(census_block_shapefile)
census_tract_canopy = masked_canopy_height.clip(census_tract_shapefile)
census_urban_areas_canopy = masked_canopy_height.clip(census_urban_areas_shapefile)

# Calculate the total land area (m²) for each census area
census_block_with_land_area = census_block_shapefile.map(lambda feature:
    feature.set('Land Area (m2)', feature.geometry().area()))

census_tract_with_land_area = census_tract_shapefile.map(lambda feature:
    feature.set('Land Area (m2)', feature.geometry().area()))

census_urban_areas_with_land_area = census_urban_areas_shapefile.map(lambda feature:
    feature.set('Land Area (m2)', feature.geometry().area()))

# Calculate the canopy cover area for each urban area (in m²)
census_block_canopy_cover_area = census_block_canopy.gt(0).multiply(ee.Image.pixelArea()) \
    .reduceRegions(
        reducer=ee.Reducer.sum(),
        collection=census_block_with_land_area,
        scale=1,  # 1-meter resolution
        crs='EPSG:5070'  # Adjust CRS if needed
    )

census_tract_canopy_cover_area = census_tract_canopy.gt(0).multiply(ee.Image.pixelArea()) \
    .reduceRegions(
        reducer=ee.Reducer.sum(),
        collection=census_tract_with_land_area,
        scale=1,  # 1-meter resolution
        crs='EPSG:5070'  # Adjust CRS if needed
    )

census_urban_areas_canopy_cover_area = census_urban_areas_canopy.gt(0).multiply(ee.Image.pixelArea()) \
    .reduceRegions(
        reducer=ee.Reducer.sum(),
        collection=census_urban_areas_with_land_area,
        scale=1,  # 1-meter resolution
        crs='EPSG:5070'  # Adjust CRS if needed
    )

# Add the proportion of canopy cover as a property
census_block_canopy_cover_proportion = census_block_canopy_cover_area.map(lambda feature:
    feature.set('canopy_cover_proportion',
                ee.Number(feature.get('sum')).divide(feature.get('land_area_m2'))))

census_tract_canopy_cover_proportion = census_tract_canopy_cover_area.map(lambda feature:
    feature.set('canopy_cover_proportion',
                ee.Number(feature.get('sum')).divide(feature.get('land_area_m2'))))

census_urban_areas_canopy_cover_proportion = census_urban_areas_canopy_cover_area.map(lambda feature:
    feature.set('canopy_cover_proportion',
                ee.Number(feature.get('sum')).divide(feature.get('land_area_m2'))))
